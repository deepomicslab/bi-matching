//
// Created by caronkey on 10/5/2021.
//
#include "include/Graph.h"
#include "include/matching.h"
#include <iostream>
#include <fstream>
#include <map>
#include <string.h>
#include <sstream>

int VERBOSE = 0;
const double ZERO = 0.00000001;
const double M_WEIGHT = 1000000;

void checkMatrixConjugate(double** matrix, int n) {
    for(int i = 1; i < n+1; i++) {
        for(int j = 1; j < n+1; j++) {
            auto t1 = matrix[i][j];
            auto t2 = matrix[conjugateIdx(j)][conjugateIdx(i)];
            if (std::abs(matrix[i][j] - matrix[conjugateIdx(j)][conjugateIdx(i)]) > ZERO) {
                std::cout<<"Error\n"<<i<<j<<std::endl;
                break;
            }
        }
    }
}
void tokenize(const std::string &str, std::vector<std::string> &tokens, const std::string &delimiters)
{
    std::string::size_type pos, lastPos = 0, length = str.length();

    using value_type = typename std::vector<std::string>::value_type;
    using size_type  = typename std::vector<std::string>::size_type;

    while (lastPos < length + 1)
    {
        pos = str.find_first_of(delimiters, lastPos);
        if (pos == std::string::npos)
        {
            pos = length;
        }

        if (pos != lastPos)
            tokens.emplace_back(str.data() + lastPos, (size_type) pos - lastPos);

        lastPos = pos + 1;
    }
}
//recall paths from iteration result paths
//void pathsRecall(std::vector<std::map<int, std::vector<int>*>*> & recallPaths) {
//    for (auto iterPaths: *recallPaths.back()) {
//        for (auto item : *iterPaths.second) {
//
//        }
//    }
//}
void print_help() {
    std::cout<<"matching is a conjugated assembly algorithm that constructs a conjugate\n"
               "map according to Barcode connection information between Contig,\n"
               "and finds the most likely connection relationship between Contig\n";
    std::cout<<"usage:\n\tmatching input.graph result.txt result.c.txt 0 1"<<std::endl;
    std::cout<<"parameters:\n";
    std::cout<<"\tinput.graph: graph generated by bDistance\n";
    std::cout<<"\tresult.txt: linear output result\n";
    std::cout<<"\tresult.c.txt: cycle output result\n";
    std::cout<<"\t0: iteration matching times, 0 means only matching once, no more iteration\n";
    std::cout<<"\t1: if output verbose information\n";
}

void parse_tgs(const char* f_name, seqGraph::Graph* g){
    std::ifstream tgs(f_name);
    std::string line;
    seqGraph::Vertex* vertex1 = nullptr;
    seqGraph::Vertex* vertex2 = nullptr;
    while( std::getline(tgs,line) )
    {
        std::stringstream ss(line);

        std::string v1, v2;
        char dir1, dir2;
        std::string course;
        int i = 1;
        while( std::getline(ss,course,' ') )
        {
            if (i == 1) {
                dir1 = course[course.size()-1];
                course.pop_back();
                v1 = course;
                vertex1 = g->addVertex(v1,"xx",1,2,1,1,2);
            } else {
                dir2 = course[course.size()-1];
                course.pop_back();
                v2 = course;
//                add to grap
                vertex2 = g->addVertex(v2,"xx",1,2,1,1,2);
                g->addJunction(vertex1, vertex2, dir1, dir2, M_WEIGHT, 1 , 1);
                vertex1 = vertex2;
                vertex2 = nullptr;
                dir1 = dir2;
//              make
            }
            i++;
        }
        std::cout<<"parse tgs down"<<"\n";
    }
    tgs.close();
}

int main(int argc, char *argv[]) {
    auto md = argv[1];
    if (strcmp(md, "help") == 0) {
        print_help();
        exit(0);
    }
    std::ifstream infile(argv[1]);
    std::ofstream resultFile(argv[2]);
    int iterRounds = std::atoi(argv[4]);
    int iterRoundsBK = iterRounds;
    std::ofstream cyclePathsFile(argv[3]);
    VERBOSE = std::atoi(argv[5]);

    std::string source, target;
    char sDir, tDir;
    double weight;
    auto* g = new seqGraph::Graph;
    parse_tgs(argv[6], g);

//    this used for path backtrack

    while (infile>>source>>sDir>>target>>tDir>>weight) {
        seqGraph::Vertex* v1;
        seqGraph::Vertex* v2;
        auto v1t = g->getVertexById(source);
        auto v2t = g->getVertexById(target);
        v1 = v1t == nullptr ? g->addVertex(source,"xx",1,2,1,1,2) : v1t;
        v2 = v2t == nullptr ? g->addVertex(target,"xx",1,2,1,1,2) : v2t;
        g->addJunction(v1, v2, sDir, tDir, weight, 1 , 1);
    }
//    matching for each connected graph
    int n = 0;
    g->parseConnectedComponents();
    std::cout<<"total nodes"<<g->getVertices()->size()<<std::endl;
    int maxI = g->subGraphCount();
    while (n< maxI) {
//        if(n==6){
//            int m = 9;
//        }
        std::cout<<"process subgraph "<<n<<"\n";
        auto subGraph = g->getSubgraph(n);
        std::cout<<"sub graph nodes: "<<subGraph->getVertices()->size()<<"\n";
        if(subGraph->getJunctions()->size() == 1) {
            n++;
            continue;
        }
        auto* m = new matching(subGraph);
//        checkMatrixConjugate(m->getMatrix(), m->getN());
//    m->main_steps();
        m->hungarian();
//        if (VERBOSE == 1) {
//            std::cout<<"final matched relation\n";
//            for(int i = 0; i < m->getN() + 1; i++) {
//                std::cout<<m->getMatched()[i]<<"\t";
//            }
//        }
        std::cout<<"\nresolve path";
//    TODO , make the path and cycles info into mathicng class
        auto paths = m->resolvePath(nullptr);
//        cyclePathsFile<<"sub\n";
//        cyclePathsFile<<"iter 0\n";
        for (auto item: *paths) {
            if (m->isCycle(item.first)) {
                cyclePathsFile<<"iter "<<0<<",graph"<<n<<"\n";
                for(const auto& v: *item.second) {
                    cyclePathsFile<<m->idx2Str(v)<<"\t";
                }
                cyclePathsFile<<"\n";
            }
        }
//    recallPaths.push_back(paths);
        int iterN = 0;
        iterRounds = iterRoundsBK;
        int prevPathSize = paths->size();
        if (paths->size() != 1) {
            while (iterRounds !=0) {
                std::cout<<"Iteration "<<iterN<<",nodes count"<<paths->size()<<"...\n";
                m->reconstructMatrix(paths);
//                checkMatrixConjugate(m->getMatrix(), m->getN());
                m->hungarian();
                paths = m->resolvePath(paths);
                if (paths->size() == prevPathSize || paths->size() == 1) {std::cout<<paths->begin()->second->size()<<"break"<<std::endl; break;}
                for (auto item: *paths) {
                    if (m->isCycle(item.first)) {
                        cyclePathsFile<<"iter "<<iterN<<",graph"<<n<<"\n";
                        for(const auto& v: *item.second) {
                            cyclePathsFile<<m->idx2Str(v)<<"\t";
                        }
                        cyclePathsFile<<"\n";
                    }
                }
                prevPathSize = paths->size();
                iterRounds--;
                iterN++;
            }
        }
        for(auto item : *paths) {
            for(const auto& v: *item.second) {
                if (v == -1) {
                    resultFile<<'c';
                    continue;
                }
                resultFile<<m->idx2Str(v)<<"\t";
            }
            resultFile<<"\n";
        }
        free(m);
        n++;
    }
    infile.close();
    resultFile.close();
    cyclePathsFile.close();
}
