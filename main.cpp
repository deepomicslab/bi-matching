//
// Created by caronkey on 10/5/2021.
//
#include "include/Graph.h"
#include "include/matching.h"
#include <iostream>
#include <fstream>
#include <map>
#include <string.h>

int VERBOSE = 0;
const double ZERO = 0.00000001;

void checkMatrixConjugate(double** matrix, int n) {
    for(int i = 1; i < n+1; i++) {
        for(int j = 1; j < n+1; j++) {
            auto t1 = matrix[i][j];
            auto t2 = matrix[conjugateIdx(j)][conjugateIdx(i)];
            if (std::abs(matrix[i][j] - matrix[conjugateIdx(j)][conjugateIdx(i)]) > ZERO) {
                std::cout<<"Error\n"<<i<<j<<std::endl;
                break;
            }
        }
    }
}
void tokenize(const std::string &str, std::vector<std::string> &tokens, const std::string &delimiters)
{
    std::string::size_type pos, lastPos = 0, length = str.length();

    using value_type = typename std::vector<std::string>::value_type;
    using size_type  = typename std::vector<std::string>::size_type;

    while (lastPos < length + 1)
    {
        pos = str.find_first_of(delimiters, lastPos);
        if (pos == std::string::npos)
        {
            pos = length;
        }

        if (pos != lastPos)
            tokens.emplace_back(str.data() + lastPos, (size_type) pos - lastPos);

        lastPos = pos + 1;
    }
}
//recall paths from iteration result paths
//void pathsRecall(std::vector<std::map<int, std::vector<int>*>*> & recallPaths) {
//    for (auto iterPaths: *recallPaths.back()) {
//        for (auto item : *iterPaths.second) {
//
//        }
//    }
//}
void print_help() {
    std::cout<<"matching is a conjugated assembly algorithm that constructs a conjugate\n"
               "map according to Barcode connection information between Contig,\n"
               "and finds the most likely connection relationship between Contig\n";
    std::cout<<"usage:\n\tmatching input.graph result.txt result.c.txt 0 1"<<std::endl;
    std::cout<<"parameters:\n";
    std::cout<<"\tinput.graph: graph generated by bDistance\n";
    std::cout<<"\tresult.txt: linear output result\n";
    std::cout<<"\tresult.c.txt: cycle output result\n";
    std::cout<<"\t0: iteration matching times, 0 means only matching once, no more iteration\n";
    std::cout<<"\t1: if output verbose information\n";
}

int main(int argc, char *argv[]) {
    auto md = argv[1];
    if (strcmp(md, "help") == 0) {
        print_help();
        exit(0);
    }
    std::ifstream infile(argv[1]);
    std::ofstream resultFile(argv[2]);
    int iterRounds = std::atoi(argv[4]);
    int iterRoundsBK = iterRounds;
    std::ofstream cyclePathsFile(argv[3]);
    VERBOSE = std::atoi(argv[5]);

    std::string source, target;
    char sDir, tDir;
    double weight;
    auto* g = new seqGraph::Graph;

//    this used for path backtrack

    while (infile>>source>>sDir>>target>>tDir>>weight) {
        seqGraph::Vertex* v1;
        seqGraph::Vertex* v2;
        auto v1t = g->getVertexById(source);
        auto v2t = g->getVertexById(target);
        v1 = v1t == nullptr ? g->addVertex(source,"xx",1,2,1,1,2) : v1t;
        v2 = v2t == nullptr ? g->addVertex(target,"xx",1,2,1,1,2) : v2t;
        g->addJunction(v1, v2, sDir, tDir, weight, 1 , 1);
    }
//    matching for each connected graph
    int n = 0;
    g->parseConnectedComponents();
    int maxI = g->subGraphCount();
    while (n< maxI) {
//        if(n==6){
//            int m = 9;
//        }
        std::cout<<"process subgraph "<<n<<"\n";
        auto subGraph = g->getSubgraph(n);
        std::cout<<"sub graph nodes: "<<subGraph->getVertices()->size()<<"\n";
        if(subGraph->getJunctions()->size() == 1) {
            n++;
            continue;
        }
        auto* m = new matching(subGraph);
//        checkMatrixConjugate(m->getMatrix(), m->getN());
//    m->main_steps();
        m->hungarian();
        std::cout<<"final matched relation\n";
        for(int i = 0; i < m->getN() + 1; i++) {
            std::cout<<m->getMatched()[i]<<"\t";
        }
        std::cout<<"\nresolve path";
//    TODO , make the path and cycles info into mathicng class
        auto paths = m->resolvePath(nullptr);
//        cyclePathsFile<<"sub\n";
//        cyclePathsFile<<"iter 0\n";
        for (auto item: *paths) {
            if (m->isCycle(item.first)) {
                for(const auto& v: *item.second) {
                    cyclePathsFile<<m->idx2Str(v)<<"\t";
                }
                cyclePathsFile<<"\n";
            }
        }
//    recallPaths.push_back(paths);
        int iterN = 1;
        iterRounds = iterRoundsBK;
        int prevPathSize = paths->size();
        if (paths->size() != 1) {
            while (iterRounds !=0) {
                std::cout<<"Iteration "<<iterN<<"...\n";
                m->reconstructMatrix(paths);
//                checkMatrixConjugate(m->getMatrix(), m->getN());
                m->hungarian();
                paths = m->resolvePath(paths);
                if (paths->size() == prevPathSize || paths->size() == 1) {std::cout<<paths->begin()->second->size()<<"break"<<std::endl; break;}
                for (auto item: *paths) {
                    if (m->isCycle(item.first)) {
                        for(const auto& v: *item.second) {
                            cyclePathsFile<<"iter "<<iterN<<"\n";
                            cyclePathsFile<<m->idx2Str(v)<<"\t";
                        }
                    }
                }
                prevPathSize = paths->size();
                iterRounds--;
                iterN++;
            }
        }
        for(auto item : *paths) {
            for(const auto& v: *item.second) {
                if (v == -1) {
                    resultFile<<'c';
                    continue;
                }
                resultFile<<m->idx2Str(v)<<"\t";
            }
            resultFile<<"\n";
        }
        n++;
    }
    infile.close();
    resultFile.close();
    cyclePathsFile.close();
}